---
title: "R Tutorial For Business Analytics"
author: "Derek Lukacsko & Jonathan Bourne"
date: "September 8, 2016"
output: html_document
---


```{r Chunk opts, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


```{r Set up hidden, message=FALSE}
# Load packages
packages <- c("tidyverse", "openxlsx")

#This piece of code will check to see if the packages you want to load are installed if they aren't it will install them
new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

invisible(sapply(packages, library, character.only = TRUE))

#save the starting directory as a variable
basewd <-getwd()
```



#Introduction

##Sources of help

1. Typing `?` followed by the function name e.g `?help` or `?sum`
1. [Google](www.google.co.uk)
2. [stackoverflow](http://www.stackoverflow.com)
3000. [Rstudio's cheatsheets](https://www.rstudio.com/resources/cheatsheets/) (for this you'll neeed the wrangling and ggplot ones)
4. [ggplot2 help website](http://docs.ggplot2.org/current/)

#Setup
Setting up the environment can be very helpful to do in one place this first code chunk can store all the packages you need in your analysis, load any custom functions that you have made through out the analysis and store the locations of any folders that you use for easy folder switching.

**TIPS** Short cuts can be very helpful especially inserting a new chunk using `ctrl+alt+i`

```{r Setting Up Environment, eval=FALSE, echo=TRUE}
# Load packages
packages <- c("tidyverse", "openxlsx")

#This piece of code will check to see if the packages you want to load are installed if they aren't it will install them
new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

invisible(sapply(packages, library, character.only = TRUE))

#save the starting directory as a variable
basewd <-getwd()
```




#Exploring the data


R contains many different data sets and additional data sets are usually installed with new packages. You can see what packages are installed on your machineby typing `data()` in the command line. packages can be loaded using the following methods
```{r, echo=TRUE}

data("airquality") #creates a promise
airquality %>% head #anything that calls the promises causes it to be evaluated
rm(airquality) #delete the dataframe

testdf <- airquality #loading can also be done like this
rm(testdf) #we don't need this variable cluttering up the workspace

```


Load the `mtcars` data frame and assign it to the variable `df`

```{r}
# Working dataframe
df <- mtcars
```


1. With the data frame you have just loaded, use the functions,`class`, `dim`, `head`, `colnames`, `names`, `View`.
1. Load the datasets `VADeaths` and `discoveries` and use the same functions, what happens? why do you think it happens?

```{r}

# Inspect the data
class(df)
dim(df)
colnames(df)
View(head(df))
head(df)
```

#Classes

In R all the objects you work with have different classes these can be data frames, matrices, models, vectors etc. Different objects have different properties, meaning they react differently to the functions you try on them.

Given that data frames can hold multiple data types it is worth checking what class each column in a data frame is. This can be boring to check one at a time so using a `for` loop could be an option. However R also has a group of functions called the `apply` family, `sapply`, and `lapply` being the most commonly used. These functions move across every element of a dataframe/matrix/list and perform a function on it returning the result.

##Check the class of each variable
1. Use sapply to sum up each column of the dataframe `df` 
1. Use `sapply` to find out the classes of each varible in `df` compare this to the classes found in the `iris` data set.
3. Do you think the results of the summming function is surprising?

```{r using sapply}

sapply(df, sum)
#sapply(iris, sum)

sapply(df, class)
#sapply(iris, class)

```

##Change class

As was seen in the previous exercise some of the variables of df could do with changing class. Class can be changed by calling `as.` before the class you want to convert to e.g `as.data.frame` if possible R will then coerce the object into the new class, or return an error if it is not possible.

A matrix can only hold a single class of information for example, integers **or** characters but not both. A data frame can hold multiple data types as long as they are vectors, this makes data frames much more flexible they are the building block of working in R. A list can hold whatever you like including other lists.


1. Change the cyl, vs, and am  variables to factors (Use `lapply` or `mutate_at` if you can work out how)
2. Change hp to an integer
3. Using sapply check the changes have taken place

**Tip** For changes to variables in a dataframe or matrix use mutate (look at the wrangling cheatsheet).

```{r}

#Old school solution using lapply
df2 <-df
df2[,c(2,8,9)] <- lapply(c(2,8,9), function(n) as.factor(df2[,n]))
df2$hp <- as.integer(df2$hp)

#Modern style using chaining and dplyr
df %<>% mutate_at(c(2,8,9), as.factor) %>% mutate(hp= as.integer(hp))

sapply(df2, class)
sapply(df, class)
```

```{r, eval= FALSE}
#Are they equal?
all.equal(sapply(df2, class), sapply(df, class))
#win
```

```{r}
#this variable is not needed, but because the previous code chunk is not evaluated it needs to be deleted here
rm(df2)
```


#Exploring Data

Getting an idea of what is going on in your data frame is an important first step in working with data, we have already learn a bit about how the data works, now we are going to go a bit deeper.

1. Use rownames() and mutate() to make a new variable called "model" that has the names of the cars
2. Use the summary function to get a an overview of the dataset
2. Return the data frame with only th first 5 car models
3. Return the data frame with the top 5 most fuel efficient cars
4. Return a dataframe with the 5 least fuel efficient cars
5. Find the most fuel efficient car for each cylinder group

```{r Exercise 1: Data Cleaning}

df <- df %>% mutate(model = rownames(.))
summary(df)
df %>% top_n(5, mpg)#top 5 unordered
df %>% arrange(desc(mpg)) %>% top_n(5, mpg) #top 5 ordered
df %>% arrange(mpg) %>% head(5) #
df %>% arrange(desc(mpg)) %>% group_by(cyl) %>% summarise_all(first)

```


#Outside the R environment
Obviously installing packages requires exiting the R environment and accessing the packages online at CRAN, however other times it is usefull to access things outside your R environment. In this section we will look at the basics of creating new folders, changing the working directory and saving files.

##Creating sub directories
In order to make our project manageable and easy to navigate we will create a new folder for the data.


1. Set the working directory to `basewd` which was defined at the begnining, you will need the function `setwd`.
2. Use the function `dir.create` to make a new folder called "R_tutorial",check that it exists.
3. Change the working directory to be inside the "R_tutorial" folder, you might want to use the `file.path` function.
4. Create a folder called `Data` and set the working directory inside it.
5. Save the file path to the Data directory as a variable call it "DataFolder"

```{r, warning=FALSE, message=FALSE}
#1
setwd(basewd)
#2
dir.create("R_tutorial")
dir.exists("R_tutorial")
#3
setwd(file.path(basewd, "R_tutorial"))
#4
dir.create("Data")
setwd("./Data") #When you are shifting down a directory you can use the "./name" method this can be shorter
#5
DataFolder <- getwd()

```


##Saving data
We have made some changes to our dataframe and so it is a good idea to save it somewhere. Getting data in and out of R that is not a preloaded dataset can be difficult when starting out so we will go through a few methods. The most common methods for saving data is `save`, `saveRDS`, `write.csv` which is a special case of `write.table`, and `write.xlsx` from the `opsenxlsx` package.

**Tip** Remember to use the correct file extension at the end of the file name when saving, it makes it easier to identify files and for them to be opened by others.


1. Save a version of df using `write.csv` (dfcsv), `saveRDS` (dfRDS), and `write.xlsx` (dfxlsx)
2. Load the files using `read.csv`, `readRDS` and `read.xlsx`
3. Using the `all.equal` function compare the loaded files to the orignial df frame, what do you notice? you can also include `sapply` to compare each of the columns of the two dataframes.
4. delete all the dfxxx dataframes from the workspace.

**Note:** You may get an error message reffering to "Rtools" when you try to use `read.xlsx`, If you do just skip the xlsx bit and install Rtools later


**TIP:** You may wish to experiment including `row.names=1` when loading the csv.

```{r saving}

#1
write.csv(df, "dfcsv.csv")
saveRDS(df, "dfRDS.rds")
#write.xlsx(df, "dfxlsx.xlsx")

#2
dfcsv <- read.csv("dfcsv.csv", row.names=1)

dfRDS <- readRDS("dfRDS.rds")

#dfxlsx <-read.xlsx("dfxlsx.xlsx")

#4
all.equal(df, dfcsv)
all.equal(df, dfRDS)
#all.equal(df, dfxlsx)

all.equal(sapply(df, class), sapply(dfcsv, class))
all.equal(sapply(df, class), sapply(dfRDS, class))
#all.equal(sapply(df, class), sapply(dfxlsx, class))

#4
rm(list = c(ls()[grep("df", ls())]))
```

The way you save files and the methods you can use to load data into your machine, affect what happens to it later. Generally saving data in RDS format is a good idea, it get compressed, and all class information is maintained, it can also be used to store other objects that are not tabular datasets, such as lists, models, etc. However you will seldom be lucky enough to recieve data in RDS format so knowing what to expect when that happens is important. Lookup the `readr` package and familiarise yourself with `stringsAsFactors` in `read.csv` that can ruin your day.

#Creating Plots
In this section we willl explore using ggplot2 R's most popular plotting package to visualise data sets. We will begin using a simple scatter plot, and then build on it's complexity by adding "layers". After the scatter plot we will create a box plot which is very useful for representing catagorical/factoral data.

**Tip:** The ggplot cheat sheet will be pretty useful

##Scatterplot 

1. Load the "iris" data set
1. Plot the relationship between variables Sepal.Length and Sepal.Width
4. add a linear regression
2. Color the points by Species
5. Bring fire

```{r Exercise 2: Scatter plotting}
#1
df<-iris

#2
ggplot(df, aes(x=Sepal.Length,y=Sepal.Width)) + 
  geom_point() +
  labs(title = "Relationship Between Sepal.Length and Sepal.Width")

# 3 add linear regression
ggplot(df, aes(x=Sepal.Length,y=Sepal.Width)) + 
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Relationship Between Sepal.Length and Sepal.Width")


#4 Add in colours
ggplot(df, aes(x=Sepal.Length,y=Sepal.Width,color = Species)) + 
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Relationship Between Sepal.Length and Sepal.Width \n by Species")

#5 plots facetted with grey dots added in the background to indicate where the other species are
ggplot(df, aes(Sepal.Length,Sepal.Width, color = Species)) +
  geom_point(data = transform(df, Species = NULL), colour = "grey85") +
  geom_point() +
  geom_smooth(method = "lm", se =FALSE) +
  facet_wrap(~Species, nrow= 2) +
 labs(title = "Relationship Between Sepal.Length and Sepal.Width \n Faceted by Species")

```


#Boxplot
Boxplots are a compact way of representing key statistics in categorical/factoral data. Often barplots are used to represent factoral data however they contain less information than barplots and so should generally be avoided.

1. Load "dfRDS.rds" and assign it to variable `df`
1. Make a barplot of mean mpg per cylinder, you will need to use `group_by` and `summarise`, also barplots need `stat="identity" in the geom.
1. Make a box plot of mpg per cylinder

```{r BoxPlots}

setwd(DataFolder) #Set the working directory just in case we changed it for some reason
df <-readRDS("dfRDS.rds")


#Doing you processing for plots in a chain is convenient if you don't need the processed data frame again.
df %>% group_by(cyl) %>% summarise(mpg=mean(mpg)) %>% 
  ggplot(., aes(x= cyl, y=mpg, fill =cyl)) + 
  geom_bar(stat="identity") +ggtitle("barplot of average miles per gallon by cylinder type")

ggplot(df, aes(x= cyl, y=mpg, fill =cyl)) + 
  geom_boxplot()+
  labs(title = "Relationship Between Cylinders and fuel efficiency")

```




1. Determine if Sepal.Length and Sepal.Width follow a Gaussian distribution using a test of normality
2. Make a histogram or frequency density plot to roughly visalize the feature distributions
3. Determine if the correlation between Sepal.Length and Sepal.Width is significant
```{r Exercise 4: test normality, test correlation}

# I don't know why df2 has been brought in
df2<-df
ggplot(df2, aes(Sepal.Width)) + 
  stat_bin(bins = 20,  fill="steelblue", color = "white") + 
  theme_bw()

ggplot(df2, aes(Sepal.Width)) + 
  geom_density(fill= "steelblue") + 
  theme_bw()

colnames(df2)
df2 <- df[,c(1:4)]
#This produces an error I don't kniw what you are trying to do
#cor.test(df2)

# Low P --> reject H0
cor.test(df2$Sepal.Length,df2$Sepal.Width, method = c("pearson"), conf.level = 0.95)[3]


```


#Asking Questions on Stackoverflow

Without SO programming would be an even more difficult and frustrating experience than it already is. SO has a lot of questions already answered, you will still probably want to ask some. However if you want to be an OG as well as an OP you should [read this](http://stackoverflow.com/help/how-to-ask) and follow a few basic rules.

1. Make sure you have actually tried. The SO community is there to answer questions not hold hands and react badly when it looks like someone hasn't attempted the question themslef first.
2. Google it first! if there is already answer outthere especially if the answer is on SO already, your question will be voted down and closed.
3. Proivide a [minimal reproducible](http://stackoverflow.com/questions/5963269/how-to-make-a-great-r-reproducible-example) example. This is the most important thing to do once you have gone through the other two points. For R the best way to create a reproducible example is using `dput`. The key is providing just enough information so that the question is answerable. 


```{r dput, eval = FALSE}
 ?dput
#The script produced can be pasted into SO, other people can then copy the code and assign it a variable 
diamonds %>% head %>% dput

#Asign this structure to "test" and have a look at it
structure(list(Ozone = c(41L, 36L, 12L, 18L, NA, 28L, 23L, 19L, 
8L, NA, 7L, 16L, 11L, 14L, 18L, 14L, 34L, 6L, 30L, 11L), Solar.R = c(190L, 
118L, 149L, 313L, NA, NA, 299L, 99L, 19L, 194L, NA, 256L, 290L, 
274L, 65L, 334L, 307L, 78L, 322L, 44L), Wind = c(7.4, 8, 12.6, 
11.5, 14.3, 14.9, 8.6, 13.8, 20.1, 8.6, 6.9, 9.7, 9.2, 10.9, 
13.2, 11.5, 12, 18.4, 11.5, 9.7), Temp = c(67L, 72L, 74L, 62L, 
56L, 66L, 65L, 59L, 61L, 69L, 74L, 69L, 66L, 68L, 58L, 64L, 66L, 
57L, 68L, 62L), Month = c(5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 
5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L), Day = 1:20), .Names = c("Ozone", 
"Solar.R", "Wind", "Temp", "Month", "Day"), row.names = c(NA, 
20L), class = "data.frame")

#By doing this, classes, variuable names and everything important about the data is preserved and people will find it much easier to help you.

```


#TEh ENDZ
